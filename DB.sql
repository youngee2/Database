SELECT * FROM tab

SELECT * FROM class

SELECT * FROM dept

SELECT * FROM student

SELECT * FROM DEPARTMENT 

SELECT NAME,STU_ID ,DEPT_NAME 
FROM student, DEPARTMENT 
WHERE student.DEPT_ID = department.DEPT_ID 
--안겹치는건 앞에 테이블 안써도 된다.

SELECT * FROM DEPARTMENT,STUDENT WHERE department.DEPT_ID = student.DEPT_ID ;

SELECT address FROM student

SELECT name FROM student

SELECT DISTINCT address  FROM student 
-- 중복된 레코드를 제거하고 검색하려면 distinct를 사용
-- student 테이블에서 address를 추출하는데 중복은 제거.

--SELECT *FROM Tab;할때  * 보다는 필드명 다 적어주는게 더 좋다.

SELECT name,2012-year_emp FROM PROFESSOR 
-- PROFESSOR 테이블에서 name 필드와, 2012-YEAR_emp 필드를 추출해서 출력한다.
--SELECT 절에 필드이름 외에 산술식이나 상수의 사용이 가능하다.

-- and or 조건은 자바와 같다. and는 둘 다 참일때 참 . or은 하나만 참이여도 참
select student.stu_id
from student, department
where student.dept_id = department.dept_id and
student.year = 3 and
department.dept_name='컴퓨터공학과'

--김광식,김정현 
--컴공 920
-- 결과는 1292001
--      1292002

SELECT name, stu_id FROM student WHERE YEAR=3 OR YEAR=4 ORDER BY name,stu_id
-- order by를 제외한 출력
-- 김광식  1292001
--김정현 1292002
--김현정  1292003
--박광수  1292303
--김우주 1292305
--박철수 1292501
--백태성 1292502

--order by로 정렬한 출력 (이름을 오른차순으로 정렬하고 같은 이름에 대해서는 학번의 오름차순으로 정렬)
--김광식	1292001
--김우주	1292305
--김정현	1292002
--김현정	1292003
--박광수	1292303
--박철수	1292501
--백태성	1292502

SELECT name,stu_id FROM STUDENT 
WHERE YEAR =3 OR YEAR = 4 ORDER BY name,STU_ID 

SELECT s2.name FROM student s1,student s2
WHERE s1.address =s2.address AND s1.NAME ='김광식'

SELECT name,POSITION ,2022-year_emp FROM professor

SELECT name 이름, POSITION 직위, 2012-year_emp 재직연수 FROM professor
--select 필드 옆에 적으면 출력할때 바뀌어서 출력

SELECT * FROM student WHERE name LIKE '김%'

SELECT * FROM student WHERE RESIDENT_ID LIKE '______*2%' 
OR RESIDENT_ID LIKE '______*4%'

SELECT * FROM student WHERE RESIDENT_ID LIKE '%*2%'OR RESIDENT_ID LIKE '%*4%'

SELECT * FROM student WHERE RESIDENT_ID LIKE '8%'

SELECT name FROM STUDENT  UNION SELECT name FROM PROFESSOR 
-- student 테이블의 학생 이름과 professor 테이블의 교수 이름을 합쳐서 출력 (합집합 union)
-- union 연산자는 연산 결과에 중복되는 값이 들어갈 경우 한번만 출력.
-- 집합 연산은 필드의 개수와 데이터타입이 서로 같아야 함.

SELECT name FROM PROFESSOR  

SELECT name FROM STUDENT  UNION ALL SELECT name FROM PROFESSOR 
-- union 결과에 중복을 제거하고 싶지 않다면 union all 연산자 사용

SELECT s.stu_id FROM STUDENT s, DEPARTMENT d ,TAKES t 
WHERE s.DEPT_ID= d.DEPT_ID AND t.STU_ID = s.STU_ID AND 
dept_name ='컴퓨터공학과' AND grade='A+'

SELECT stu_id FROM student s, DEPARTMENT d WHERE s.DEPT_ID = d.DEPT_ID 
AND DEPT_name='컴퓨터공학과' INTERSECT SELECT STU_ID FROM TAKES WHERE grade='A+';

select stu_id from student s, department d
where s.dept_id = d.dept_id and dept_name='산업공학과'
minus
select stu_id from takes
where grade = 'A+'

SELECT title,credit,YEAR, semester FROM course,class WHERE course.COURSE_ID =class.COURSE_ID 

SELECT *FROM COURSE c 

SELECT title,credit, YEAR, semester FROM course LEFT OUTER JOIN class USING (course_id)
--course 테이블과 class 테이블에 대해 왼쪽 외부조인을 적용
--조인 조건이 course.course_id = class.COURSE_ID라는 것을 의미

SELECT * FROM CLASS c 

select title, credit, year, semester
from course, class
where course.course_id = class.course_id (+)
--oracle에 특화된 쿼리 

SELECT title,credit, YEAR, semester FROM COURSE RIGHT OUTER JOIN class USING (COURSE_id)

SELECT title,credit, YEAR, semester FROM course,class WHERE course.COURSE_ID(+)=class.COURSE_ID 

select title, credit, year, semester
from course full outer join class
using (course_id)
--양쪽 테이블에서 서로 일치하는 레코드가 없을 경우, 해당 레코드들도 결과 테이블에 포함시키며 나머지 필드에 대해서는 모두 NULL

SELECT count(*) FROM STUDENT WHERE YEAR=3
--count(*) 해당 테이블에서 몇 명인지 

SELECT * FROM emp

SELECT count(COMM) FROM EMP  
--null값은 제외

SELECT count(mgr) FROM emp

SELECT count(DEPT_ID) FROM STUDENT  

SELECT count(DISTINCT dept_id) FROM STUDENT s 
-- distinct 키워드를 사용하면 중복되는 데이터를 제외한 개수를 리턴

SELECT count(*) FROM student s, DEPARTMENT d WHERE s.DEPT_ID = d.DEPT_ID AND d.DEPT_NAME ='컴퓨터공학과'

SELECT sum(2022-YEAR_emp) FROM PROFESSOR  

SELECT name,2022-YEAR_EMP  FROM PROFESSOR p 

SELECT * FROM emp

SELECT sum(SAL) FROM emp

SELECT sum(SAL) FROM emp WHERE job='ANALYST'

SELECT sum(sal) FROM emp e,dept d WHERE e.DEPTNO = d.DEPTNO AND dept.DNAME ='RESEARCH'

SELECT sum(sal) FROM emp WHERE job = 'CLERK'  

SELECT sum(sal) FROM emp WHERE job = 'SALESMAN'  

SELECT sum(sal) FROM emp WHERE job = 'MANAGER'

SELECT sum(sal) FROM emp WHERE job = 'ANALYST'  

SELECT sum(sal) FROM emp WHERE job = 'PRESIDENT' 

SELECT avg(2022-YEAR_emp) FROM PROFESSOR p 



SELECT ename,sal+COMM FROM emp

SELECT max(sal), min(sal), avg(sal) FROM EMP e, DEPT d WHERE e.DEPTNO = d.DEPTNO AND dname='ACCOUNTING'

SELECT sal FROM EMP e, DEPT d  WHERE e.DEPTNO =d.DEPTNO 

SELECT DISTINCT  job FROM EMP e 
-- CLERK, SALESMAN, MANAGER, ANALYST, PRESIDENT

SELECT * FROM STUDENT s 

SELECT dept_id,count(*) FROM student GROUP BY DEPT_ID 

SELECT * FROM DEPARTMENT d 

SELECT * FROM PROFESSOR p 

SELECT DEPT_name, count(*) FROM STUDENT s ,DEPARTMENT d WHERE s.DEPT_ID=d.DEPT_ID  GROUP BY DEPT_NAME 

SELECT dname,count(*),avg(sal),max(sal),min(sal) FROM emp e, DEPT d WHERE e.DEPTNO = d.DEPTNO GROUP BY dname

SELECT dept_name,count(*),avg(2012-year_emp), max(2012-year_emp) 
FROM PROFESSOR p ,DEPARTMENT d WHERE p.DEPT_ID =d.DEPT_ID 
GROUP BY DEPT_name ORDER BY dept_name

SELECT dept_name, count(*), avg(2012-year_emp),max(2012-year_emp) 
FROM professor p, DEPARTMENT d 
WHERE p.DEPT_ID =d.DEPT_ID 
GROUP BY DEPT_name
HAVING avg(2012-year_emp)>=10

SELECT dname,count(*),avg(sal),max(sal),min(sal) 
FROM EMP e ,DEPT d 
WHERE e.DEPTNO = d.DEPTNO 
GROUP BY dname
HAVING count(*)>=5

SELECT * FROM EMP e 

SELECT * FROM emp WHERE comm IS NOT NULL
-- 널 빼고 검색

SELECT * FROM emp WHERE comm IS NULL 
-- comm 필드에 널 값이 들어있으면 출력

SELECT * FROM TAKES t  

SELECT stu_id FROM TAKES t  WHERE grade !='A+'
-- where not 이면 그 반대의 경우. != 도 반대의 경우, <>도 사용할 수 있음.

SELECT * FROM course

SELECT * FROM class

SELECT title FROM course WHERE course_id in(SELECT DISTINCT COURSE_ID FROM class WHERE classroom='301호')
-- course 테이블에서 title을 출력하는데 class테이블에서 COURSE_ID가 중복없앤다음 classroom이 301호인 쿼리가 앞 쿼리에 포함되면
-- 출력.

SELECT DISTINCT title FROM course c1, CLASS c2 WHERE c1.COURSE_ID = c2.COURSE_ID AND classroom='301호'
-- title을 출력하는데 중복되지 않게 출력한다. course 테이블에 course_id와 class테이블에 course id가 일치하면서 classroom이 301호
--인 곳을 출력.

SELECT title FROM COURSE c WHERE course_id NOT IN (SELECT DISTINCT course_id FROM class WHERE YEAR = 2012 
AND semester =2 )
-- title을 출력하는데 course테이블의 course_id랑 class테이블의 course_id랑 겹치지 않으면서 class 테이블의 year 연도가 2012이고 
--semester가 2가 아닌 것들을 출력한다.

SELECT * FROM course

SELECT * FROM class

CREATE VIEW v_takes AS SELECT stu_id,class_id FROM takes
-- view의 역할은 기존 테이블에서 원하는 필드만 가상의 테이블로 구성할 수 있음.
-- view는 내용 중 일부를 숨길 수 있기 때문에 보안의 효과와 질의를 간단히 표현할 수 있음.
-- 생성된 view는 테이블과 동등하게 사용.
-- create or replace view <뷰이름> as <select문>
-- or replace 키워드를 추가하면 이름이 같은 뷰가 존재하는 경우 기존의 뷰를 지우고 새로 생성.
-- 여기서 select문은 뷰 생성에 사용됨.

SELECT * FROM STUDENT s 

CREATE OR REPLACE VIEW cs_student AS 
SELECT s.stu_id, s.resident_id,s.name,s.YEAR,s.address,s.dept_id
FROM student s, department d
WHERE s.DEPT_ID =d.DEPT_ID AND 
d.DEPT_NAME ='컴퓨터공학과'

SELECT *FROM CS_STUDENT cs 

CREATE OR REPLACE VIEW v_TAKES AS SELECT stu_id, class_id FROM takes

SELECT * FROM V_TAKES vt WHERE stu_id ='1292001'

INSERT INTO V_TAKES VALUES ('1292502','C101-01')

SELECT * FROM V_TAKES vt 

SELECT * FROM TAKES t 

DROP VIEW V_TAKES  


CREATE OR REPLACE VIEW v_takes AS
SELECT stu_id, class_id
FROM takes
WITH READ ONLY

--INSERT INTO v_takes VALUES('123456','C101-01')
-- read only기 때문에 데이터 추가 못함.